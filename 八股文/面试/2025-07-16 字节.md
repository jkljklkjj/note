首先是自我介绍

1. 你觉得聊天室项目最难的点在哪里

我觉得是在消息的处理上。我有用协议去封装一个消息，包括协议首部和数据。首部就包括消息类型字段，比如说心跳信息、单聊信息和群聊信息。服务器收到信息后，会根据这个字段传入对应的创建方法，获取对应的实现类，最后交给对应的类去处理这个消息

2. 策略模式具体是怎么实现的
我是先定义一个接口，里面有个处理信息的方法。然后写了多个实现类，比如说心跳信息处理类等等。然后又写了个工厂，根据传入的字符串返回对应的实现类。这个类的实现的对应方法就会被调用

3. 你的聊天室项目，发送信息后多久能到达

大概200ms，还没测试高并发的情况。

2. 你觉得这个时间的瓶颈点主要在哪里

我觉得主要是接收客户端的信息，然后在ConcurrentHashMap里面找到对应Channel，还有发送的耗时吧

3. 那你觉得怎么样能优化这个时间

4. 你说是ConcurrentHashMap存储的，那是不是存储的地方不是数据库

嗯，我是存到内存里面的

5. 存到内存，那就是说这是个单体项目？怎么能把它部署到多台服务器呢？

应该是用Zookeeper去注册多个服务器吧？到时候如果传过来一个信息，就检测对应的服务器在哪里？
修正版：我觉得用户上线的时候，会随机在一个服务器里面上线。同时给Redis统一管理用户账号和服务器实例之间的对应关系。然后服务器只订阅和自己的实例名称对应的topic，一旦有信息就可以随时拉取。相对于离线信息转发，用户上线的时候是拉取根据自己账号生成的key，之后就不会再继续订阅了。如果一直维持每个用户的订阅的话，这样性能损耗太高了。总结，服务器之间用Kafka来进行沟通。

6. 这个聊天室用的是推模式还是拉模式

大部分情况，就是用户在线的时候是推模式。收到一个客户端信息后会找到对应的目标客户端的Channel。推模式的话比较及时，虽然连接的维持对服务器性能要求高，但是用户在线的时候时候也会经常主动发信息吧，损耗的提高上不是很大。虽然说有可能会超过客户端的接收能力，但是聊天室很少会出现这种情况。用户离线上线后用的是拉模式，因为可能上线的时候用户网络很可能不稳定，而且

7. 你这个实际上用的是长连接吧。那如果长连接断开了之后会怎么处理呢？

客户端一定时间会自动离线断开长连接，这时候算是离线状态了，好像QQ里面是定义成忙碌状态，当成离线状态处理。然后客户端检测到重新上线之后就会类似重新登陆一样吧。

8. 能解释一下HashMap的原理吗？

首先它是一个结合了数组和链表的数据结构。装入对象的时候会计算对象的hashCode，然后和数组的长度取余，就存入数组的对应位置。如果两个元素和取余结果在同一位置，就会产生哈希冲突。这个时候数组存储的就是链表的头结点，然后把新元素放进链表。jdk1.8之后如果链表长度超过8就会把链表转换成红黑树，这样查询的会更快。

9. 为什么链表长度超过8会转变成红黑树，为什么是这个长度？

首先红黑树它的维护也需要时间。链表的查询效率是On，红黑树是Ologn，但是在数据量小的时候这两个时间实际上差距不大。这时候链表因为不需要被维护所以性能可能会更好点。

10. 你觉得数据库的瓶颈点在哪里？

11. 你说索引适合读多写少的情况，那读多写多的情况该不该加索引呢？

12. 那读多写多的场景下，很难保证缓存的一致性，怎么办？

我的聊天室用的是写后双删的。也就是修改前会先删缓存，然后sleep一段时间后会二次删除缓存。

12. 你认为你的商城项目和聊天室项目最大的区别在哪里？或者说，你觉得微信和淘宝之间的区别在哪里？

微信大部分情况的业务集中在消息的收发，但是淘宝必须要保证商品的各种业务，并把它们联系起来。

13. 你认为Spring的最大优势在哪里

Spring主要是个框架，我觉得重点是在MVC架构的封装和一些Starter吧。
*主要在aop和ioc*

14. 解释一下IOC

IOC就是一个spring对bean的处理的一种封装。首先会把创建好的对象创建成bean，交给BeanFactory来统一管理。其它类需要用到这个对象的时候就能很方便的去获取

15. 那IOC有什么好处呢

首先很大程度上简化了对象的创建过程，比如说用注解来注入。同时可以保证bean的一致性吧，谁需要的时候给的bean都是同一个，也很好地能实现单例模式
*还能统一管理所有的bean的生命周期，避免了过多的编码*

16. Bean什么时候不是单例呢

在定义bean的时候在beanDefinition的时候指定bean的Scope吧，包括单例，多例，session这些。其他情况的现在不清楚

17. 两两交换

只用迭代法做得差不多出来，还是不熟悉ACM模式。如果十分钟能做出来应该会要求用递归解出来
