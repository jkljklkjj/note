我们要获取一个对象，如果应用场景多的话，就需要把创建的任务交给工厂
工厂的创建逻辑也可以复杂化，进行任务的分离，让专业的类干专业的事

工厂模式通常涉及以下几个角色：

抽象工厂（Abstract Factory）：定义一个创建对象的接口，但不负责具体的对象创建过程。它通常是一个接口或者抽象类，其中定义了一个或多个创建对象的方法。

具体工厂（Concrete Factory）：实现抽象工厂接口，负责实际创建具体的对象。每个具体工厂都对应着一种具体的对象类型。

产品（Product）：工厂所创建的对象类型。它可以是一个接口、抽象类或者具体类。

具体产品（Concrete Product）：实现产品接口的具体对象。工厂模式的每个具体工厂都负责创建特定的具体产品。

工厂模式的主要目的是将对象的创建过程封装在工厂类中，客户端代码只需要关心从工厂获取对象的过程，而不需要了解对象的创建细节。这样可以降低代码的耦合度，提高代码的可维护性和可扩展性

工厂模式有三种，分别是简单工厂模式、工厂方法模式、抽象工厂模式。三种模式从前到后越来越抽象，也更具有一般性

首先我们需要实现根据需求进行对应的操作，用最简单的方式实现
```java
public void ifElseTest(){
        String type = "chicken";
        if ("chicken".equals(type)) {
            System.out.println("鸡肉面");
        } else if ("beef".equals(type)) {
            System.out.println("牛肉面");
        } else if ("vegetarian".equals(type)) {
            System.out.println("素面");
        } else {
            System.out.println("面条不存在");
        }
    }
```

#### 简单工厂实现

定义操作类
```java
public interface Noodle {
 
    /**
     *  制作接口类
     * @author yiridancan
     **/
    void cook();
 
}
```

定义多个具体实现
```java
/**
 * 牛肉面实现类
 * @author yiridancan
 **/
public class BeefNoodle implements Noodle{
    @Override
    public void cook() {
        System.out.println("牛肉面正在准备中...");
    }
}
 
 
 
/**
 * 鸡肉面实现类
 * @author yiridancan
 **/
public class ChickenNoodle implements Noodle{
    @Override
    public void cook() {
        System.out.println("鸡肉面正在准备中...");
    }
}
 
 
/**
 * 素面实现类
 * @author yiridancan
 **/
public class VegetarianNoodle implements Noodle{
    @Override
    public void cook() {
        System.out.println("素面正在准备中...");
    }
}
```

