#树
对于这类题目，需要把脑筋转起来
1. 这个函数解决什么问题
2. 叶子结点的条件和返回值
3. 这个问题和左右子树子问题的解的关系
4. 进阶后，一个问题可能需要解决多个问题，那么我们就要清楚这些多个问题是什么，分步来解决，可以用递归来达成什么目的

**103. 树的最大深度**
最经典的树题目，把递归体现的淋漓尽致
一个节点为根的子树，它的最大深度一定是由它两颗子树计算出来的
取最大深度最大的子树，加上1就是这个节点的答案

```java
public int maxDepth(TreeNode root) {
	if(root==null) return 0;
	return Math.max(maxDepth(root.left),maxDepth(root.right))+1;
}
```

**226. 翻转二叉树**
一个节点获取它的两个子树翻转后的结果，再把这两个子树进行交换

```java
public TreeNode invertTree(TreeNode root) {
	if(root==null) return null;
	TreeNode left = invertTree(root.left);
	TreeNode right = invertTree(root.right);
	root.left = rght;
	root.right = left;
	return root;
}
```

**101. 对称二叉树**
定义一个子问题：这两个节点是否对称
记得要判断是否有空值，不然获取val的时候会报空指针错误
同时这两个点往对称方向一直移动

```java
public boolean isSymmetric(TreeNode root) {
	return check(root, root);
}

public boolean check(TreeNode p, TreeNode q){
	if(p==null && q==null) return true;
	if(p==null || q==null) return false;
	return p.val==q.val && check(p.left,q.right) && check(p.right,q.left);
}
```

也可以用迭代法解决，这个解法必须记住
每次队列弹出的两个元素肯定是位于树的对称位置

```java
public boolean isSymmetric(TreeNode root) {
	Queue<TreeNode> q = new LinkedList<TreeNode>();
	q.offer(root);
	q.offer(root);
	while(!q.isEmpty()){
		TreeNode u = q.poll();
		TreeNode v = q.poll();
		if(u==null && v==null) continue;
		if(u==null||v==null||u.val!=v.val){
			return false;
		}
		q.offer(u.left);
		q.offer(v.right);

		q.offer(u.right);
		q.offer(v.left);
	}
	return true;
}
```

**543. 二叉树的直径**
找到最长路径
一个点所在的最长路径，肯定是它两个孩子的最长路径长度加上它
那就搜索计算所有点的最长路径，记录最长的即可

```java
int ans = 1;
public int diameterOfBinaryTree(TreeNode root) {
	depth(root);
	return ans-1;
}

public int depth(TreeNode node){
	if(node==null) return 0;
	int l = depth(node.left);
	int r = depth(node.right);
	ans = Math.max(ans, l+r+1);
	return Math.max(l,r)+1;
**108. 将有序数组转换成二叉搜索树**
实际上也能处理将数组转成二叉树的操作

```java
public TreeNode sortedArrayToBST(int[] nums) {
	return sort(nums,0,nums.length-1);
}

public TreeNode sort(int[] nums, int l, int r){
	if(l>r) return null;
	int mid = (l+r)>>1;
	TreeNode node = new TreeNode(nums[mid]);
	node.left = sort(nums,l,mid-1);
	node.right = sort(nums,mid+1,r);
	return node;
}
```

**98. 验证二叉搜索树**
传入上下界，注意因为是开区间所以要传入比整数范围更大的边界

```java
public boolean isValidBST(TreeNode root) {
	return isValidBST(root,Long.MIN_VALUE,Long.MAX_VALUE);
}

public boolean isValidBST(TreeNode node, long lower, long upper){
	if(node==null) return true;
	if(node.val<=lower || node.val>=upper) return false;
	return isValidBST(node.left, lower, node.val) && isValidBST(node.right, node.val,upper);
}
```

**199. 树的右视图**
采用改进的先序遍历：节点、右子树、左子树
每次遍历到的对应层数的第一个节点必定为右视图节点
则ans的对应索引则为层数，深度一旦超过层数则可知道该节点为这一层搜到的第一个节点

```java
public List<Integer> rightSideView(TreeNode root) {
	List<Integer> ans = new ArrayList<>();
	dfs(root,0,ans);
	return ans;
}

private void dfs(TreeNode root, int depth, List<Integer> ans){
	if(root==null) return;
	if(depth==ans.size()) ans.add(root.val);
	dfs(root.right, depth+1, ans);
	dfs(root.left, depth+1, ans);
}
```

**114. 二叉树转链表**
把二叉树转换成先序遍历后的链表
但是如果是先序遍历加尾插法，那需要维护一个虚拟的头结点才可以
所以使用逆先序遍历（右子树、左子树、根）和头插法，最后root即为新的头结点

```java
private TreeNode head;
public void flatten(TreeNode root) {
	if(root==null) return;
	flatten(root.right);
	flatten(root.left);
	root.left = null;
	root.right = head;
	head = root;
}
```

**105. 前序中序构造二叉树**
前序序列为：根 | 左子树前序序列 | 右子树前序序列
中序序列为：左子树中序序列 | 根 | 右子树中序序列
所以可以理解为，通过前序序列找到根，通过根找到左右子树中序序列，通过中序序列找到左右子树前序序列的大小从而找到左右子树前序序列。后面根左边连上左子树前序中序序列子问题的结果，右边连上右子树前序中序序列子问题的结果即可

```java
public TreeNode buildTree(int[] preorder, int[] inorder) {
	int n = preorder.length;
	// 快速找到中序序列中根的索引
	Map<Integer, Integer> index = new HashMap<>(n);
	for (int i = 0; i < n; i++) {
		index.put(inorder[i], i);
	}
	return dfs(preorder, 0, n, 0, n, index);
}

// 先序序列，先序序列的左闭右开区间，中序序列的左开右闭区间，位置索引
private TreeNode dfs(int[] preorder, int preL, int preR, int inL, int inR, Map<Integer, Integer> index) {
	// 要建立的树为空
	if (preL == preR)
		return null;
	// 根的索引减去左边界即为左子树大小
	int leftSize = index.get(preorder[preL]) - inL;
	// 可以看到左区间的右边界差不多等于右区间的左边界
	// 子区间的一些边界也等于原区间的
	TreeNode left = dfs(preorder, preL + 1, preL + 1 + leftSize, inL, inL + leftSize, index);
	TreeNode right = dfs(preorder, preL + 1 + leftSize, preR, inL + 1 + leftSize, inR, index);
	return new TreeNode(preorder[preL], left, right);
}
```

**437. 路径总和**
寻找一条路径，路径之和等于k。路径指所有边只能从父节点到子节点
类似[[560. 和为K的子数组]]，区别是要搜索root到每个节点的路径形成的数组

可以看到sum不需要减去刚刚加的值，但是哈希表却要
是因为基本类型可以自动回溯到当前状态，但是引用传递要手动处理，这就是回溯算法的本质

快速记忆：
1. 新建哈希表，初始化无路径的前缀和0为1种情况
2. 深搜，维护路径上的前缀和
3. 哈希表维护当前路径的所有前缀和数量，结果加上满足条件的数量
4. 哈希表加上当前前缀和后继续搜索，搜索完后回溯哈希表状态

```java
private int ans;

public int pathSum(TreeNode root, int targetSum) {
	Map<Long, Integer> cnt = new HashMap<>();
	cnt.put(0L,1);
	dfs(root,0,targetSum,cnt);
	return ans;
}

private void dfs(TreeNode node, long sum, int targetSum, Map<Long,Integer> cnt){
	if(node==null) return;

	sum+=node.val; //当前路径前缀和
	// 寻找目前路径上所有节点为终点的前缀和
	ans+=cnt.getOrDefault(s-targetSum,0);

	cnt.merge(sum,1,Integer::sum);
	dfs(node.left,sum,targetSum,cnt);
	dfs(node.right,sum,targetSum,cnt);
	cnt.merge(sum,-1,Integer::sum);
}
```

**236. 最近公共祖先LCA**
求两个节点的最近的公共祖先

函数返回最近的公共祖先
如果节点为空或者为p或q，直接返回自己
深搜左右子树，如果返回的为空则证明这个子树没有p和q
如果左右都包含，证明自己就是最近公共祖先
如果只有一个子树包含，说明答案在这个子树中

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
	if(root==null || root==p || root==q) return root;
	TreeNode l = lowestCommonAncestor(root.left,p,q);
	TreeNode r = lowestCommonAncestor(root.right,p,q);
	return l==null ? r:(r==null?l:root);
}
```

**124. 最大路径和**
一个路径肯定是一个根节点加上左右两条向下的路径

那么就可以求出所有节点向下的路径的最大路径和，然后一个节点为中点的最大路径即为它加上左右两条最大路径。用一个静态变量存储最大结果即可

```java
int maxSum = Integer.MIN_VALUE;

public int maxPathSum(TreeNode root) {
	maxGain(root);
	return maxSum;
}

public int maxGain(TreeNode node){
	if(node==null) return 0;
	int left= Math.max(maxGain(node.left),0);
	int right = Math.max(maxGain(node.right),0);

	int priceNewPath = node.val+left+right;
	maxSum = Math.max(maxSum,priceNewPath);

	return node.val+Math.max(left,right);
}
```