对于这类题目，需要把脑筋转起来
1. 这个函数解决什么问题
2. 叶子结点的条件和返回值
3. 这个问题和左右子树子问题的解的关系
4. 进阶后，一个问题可能需要解决多个问题，那么我们就要清楚这些多个问题是什么，分步来解决，可以用递归来达成什么目的

**103. 树的最大深度**
最经典的树题目，把递归体现的淋漓尽致
一个节点为根的子树，它的最大深度一定是由它两颗子树计算出来的
取最大深度最大的子树，加上1就是这个节点的答案

```java
public int maxDepth(TreeNode root) {
	if(root==null) return 0;
	return Math.max(maxDepth(root.left),maxDepth(root.right))+1;
}
```

**226. 翻转二叉树**
一个节点获取它的两个子树翻转后的结果，再把这两个子树进行交换

```java
public TreeNode invertTree(TreeNode root) {
	if(root==null) return null;
	TreeNode left = invertTree(root.left);
	TreeNode right = invertTree(root.right);
	root.left = rght;
	root.right = left;
	return root;
}
```

**101. 对称二叉树**
定义一个子问题：这两个节点是否对称
记得要判断是否有空值，不然获取val的时候会报空指针错误
同时这两个点往对称方向一直移动

```java
public boolean isSymmetric(TreeNode root) {
	return check(root.left, root.right);
}

public boolean check(TreeNode p, TreeNode q){
	if(p==null && q==null) return true;
	if(p==null || q==null) return false;
	return p.val==q.val && check(p.left,q.right) && check(p.right,q.left);
}
```

也可以用迭代法解决，这个解法必须记住
每次队列弹出的两个元素肯定是位于树的对称位置

```java
public boolean isSymmetric(TreeNode root) {
	Queue<TreeNode> q = new LinkedList<TreeNode>();
	q.offer(root);
	q.offer(root);
	while(!q.isEmpty()){
		TreeNode u = q.poll();
		TreeNode v = q.poll();
		if(u==null && v==null) continue;
		if(u==null||v==null||u.val!=v.val){
			return false;
		}
		q.offer(u.left);
		q.offer(v.right);

		q.offer(u.right);
		q.offer(v.left);
	}
	return true;
}
```