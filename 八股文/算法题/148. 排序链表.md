将链表重新排序成一个有序链表

思路1：归并排序，包括找到链表中点和合并链表的操作

快速记忆1：
1. 定义函数sortList，传入链表的头节点和虚拟尾节点，作用是排序链表
2. 如果头结点为空，直接返回
3. 如果只有一个节点，就撤离虚拟尾节点并返回这个节点
4. 找到链表中点
5. 以中点分割链表，合并两个子链表并返回
6. 编写[[21. 合并有序链表|合并有序链表的函数]]

```java
public ListNode sortList(ListNode head) {
	return sortList(head, null);
}

public ListNode sortList(ListNode head, ListNode tail){
  if(head==null) return head;
  if(head.next==tail){
	head.next = null;
	return head;
  }
  ListNode slow = head, fast = head;
  while(fast!=tail){
	slow = slow.next;
	fast = fast.next;
	if(fast!=tail){
	  fast = fast.next;
	}
  }
  ListNode mid = slow;
  ListNode list1 = sortList(head, mid);
  ListNode list2 = sortList(mid,tail);
  ListNode sorted = merge(list1, list2);
  return sorted;
}

public ListNode merge(ListNode head1, ListNode head2){
  ListNode dummyHead = new ListNode(0);
  ListNode tmp = dummyHead, tmp1 = head1, tmp2 = head2;
  while(tmp1 !=null && tmp2!=null){
	if(tmp1.val<=tmp2.val){
	  tmp.next = tmp1;
	  tmp1 = tmp1.next;
	} else {
	  tmp.next = tmp2;
	  tmp2 = tmp2.next;
	}
	tmp = tmp.next;
  }
  if(tmp1!=null){
	tmp.next = tmp1;
  } else if(tmp2!=null){
	tmp.next = tmp2;
  }
  return dummyHead.next;
}
```

思路2：在思路1的基础上，使用自底向上的归并排序，空间复杂度变成O(1)

快速记忆2：
1. 记录链表总长度
2. 找到所有两个相邻的子链表，断开子链表和其余链表，并合并
3. 记录合并后链表的前后指针，并重新放在对应位置
4. 在上面的基础上，子链表长度乘以2，再次合并
5. 返回最后的子链表

```java
public ListNode sortList(ListNode head) {
	if(head==null) return head;
	int length = 0;
	ListNode node = head;
	while(node!=null){
		length++;
		node = node.next;
	}
	ListNode dummyHead = new ListNode(0,head);
	for(int subLength = 1;subLength<length;subLength<<=1){
		ListNode pre = dummyHead, cur = dummyHead.next;
		while(cur!=null){
			ListNode head1 = cur;
			for(int i = 1;i<subLength && cur.next!=null;i++){
				cur = cur.next;
			}
			ListNode head2 = cur.next;
			cur.next = null;
			cur = head2;
			for(int i = 1;i<subLength && cur!=null && cur.next!=null;i++){
				cur = cur.next;
			}
			ListNode next = null;
			if(cur!=null){
				next = cur.next;
				cur.next = null;
			}
			ListNode merged = merge(head1,head2);
			pre.next = merged;
			while(pre.next!=null){
				pre = pre.next;
			}
			cur = next;
		}
	}
	return dummyHead.next;
}
```