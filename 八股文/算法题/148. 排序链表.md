#链表 #递归
将链表重新排序成一个有序链表

思路1：归并排序，包括找到链表中点和合并链表的操作

快速记忆1：
1. 定义函数sortList，传入链表的头节点和虚拟尾节点，作用是排序链表
2. 如果头结点为空，直接返回
3. 如果只有一个节点，就撤离虚拟尾节点并返回这个节点
4. 找到链表中点
5. 以中点分割链表，合并两个子链表并返回
6. 编写[[21. 合并有序链表|合并有序链表的函数]]

```java
public ListNode sortList(ListNode head) {
	return sortList(head, null);
}

public ListNode sortList(ListNode head, ListNode tail) {
	if (head == null)
		return head;
	if (head.next == tail) {
		head.next = null;
		return head;
	}
	ListNode slow = head, fast = head;
	while (fast != tail && fast.next!=tail) {
		slow = slow.next;
		fast = fast.next.next;
	}
	ListNode list1 = sortList(head, slow);
	ListNode list2 = sortList(slow, tail);
	ListNode sorted = merge(list1, list2);
	return sorted;
}

public ListNode merge(ListNode a, ListNode b) {
	ListNode dummyHead = new ListNode(0);
	ListNode cur = dummyHead;
	while (a != null && b != null) {
		if (a.val < b.val) {
			cur.next = a;
			a = a.next;
		} else {
			cur.next = b;
			b = b.next;
		}
		cur = cur.next;
	}
	if (a != null) {
		cur.next = a;
	} else if (b != null) {
		cur.next = b;
	}
	return dummyHead.next;
}
```

思路2：在思路1的基础上，使用自底向上的归并排序，空间复杂度变成O(1)

快速记忆2：
1. 记录链表总长度
2. 找到所有两个相邻的子链表，断开子链表和其余链表，并合并
3. 记录合并后链表的前后指针，并重新放在对应位置
4. 在上面的基础上，子链表长度乘以2，再次合并
5. 返回最后的子链表

```java
public ListNode sortList(ListNode head) {
	if(head==null) return head;
	// 记录链表总长度
	int length = 0;
	ListNode node = head;
	while(node!=null){
		length++;
		node = node.next;
	}
	ListNode dummyHead = new ListNode(0,head);
	// 每次遍历合并相邻子串
	for(int subLength = 1;subLength<length;subLength<<=1){
		ListNode pre = dummyHead, cur = dummyHead.next;
		while(cur!=null){
			// 通过长度获取子串
			ListNode head1 = cur;
			for(int i = 1;i<subLength && cur.next!=null;i++){
				cur = cur.next;
			}
			// 断开子串和后面的链接
			ListNode head2 = cur.next;
			cur.next = null;
			cur = head2;
			for(int i = 1;i<subLength && cur!=null && cur.next!=null;i++){
				cur = cur.next;
			}
			// 记录合并后子串的前后指针
			ListNode next = null;
			if(cur!=null){
				next = cur.next;
				cur.next = null;
			}
			ListNode merged = merge(head1,head2);
			pre.next = merged;
			// 移动前指针到合并后子串的前面
			while(pre.next!=null){
				pre = pre.next;
			}
			cur = next;
		}
	}
	return dummyHead.next;
}
```