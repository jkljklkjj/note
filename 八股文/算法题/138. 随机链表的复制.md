#链表
相比于普通链表，随机链表的每个节点多了个指针，指向随机的节点
由于无法通过普通的方法一步步创建链表，所以比较复杂

思路1：通过哈希表存储所有创建好的节点，如果对应节点的next或random没有被创建则通过递归创建完毕之后再连接到节点。无指针的节点为键，完整的结果节点为值

快速记忆1：
1. 创建哈希表，键为无指针的节点，值为完整的结果节点
2. 如果节点为空则直接返回
3. 如果对应节点没有被创建，则先创建只有val的节点
4. 让next和random指向对应的节点的递归结果
5. 返回头结点的结果

```java
Map<Node, Node> cache = new HashMap<>();
public Node copyRandomList(Node head) {
	if(head==null) return null;
	if(!cache.containsKey(head)){
	  Node node = new Node(head.val);
	  cache.put(head, node);
	  node.next = copyRandomList(head.next);
	  node.random = copyRandomList(head.random);
	}
	return cache.get(head);
}
```

思路2：哈希表需要占用空间，那我们有没有办法优化这个空间。我们给链表的每个节点后面插入这个节点的拷贝，我们只要处理这个节点的拷贝即可。

快速记忆2：
1. 给每个节点后面加上它的拷贝节点
2. 拷贝节点的random指向原节点的random指向的节点的拷贝
3. 删除原节点只保留拷贝节点

```java
public Node copyRandomList(Node head) {
	if(head==null) return null;
	// 给每个节点后面加上拷贝节点
	for(Node node = head;node!=null;node = node.next.next){
	  Node nodeNew = new Node(node.val);
	  nodeNew.next = node.next;
	  node.next = nodeNew;
	}
	// 拷贝节点的random指向原节点的random节点的拷贝
	for(Node node = head;node!=null;node = node.next.next){
	  Node nodeNew = node.next;
	  nodeNew.random = (node.random!=null)?node.random.next:null;
	}
	// 删除原节点只保留拷贝的节点
	Node headNew = head.next;
	for(Node node = head;node!=null;node = node.next){
	  Node nodeNew = node.next;
	  node.next = node.next.next;
	  nodeNew.next = (nodeNew.next!=null)?nodeNew.next.next:null;
	}
	return headNew;
}
```