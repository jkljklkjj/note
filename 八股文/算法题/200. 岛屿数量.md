最经典的一道
数出有多少个连通分量

思路1：每次到一个新的连通分量，就用dfs把整个分量的位置标记，下次就不会进入同一个连通分量

快速记忆1：
1. 遍历地图
2. 如果为1，则答案+1，进入深搜
3. 注意边界条件，将所在连通分量全变0
4. 返回结果

```java
int[][] dirs = {{0,1},{0,-1},{-1,0},{1,0}};
public int numIslands(char[][] grid) {
	int ans = 0;
	int n = grid.length, m = grid[0].length;
	boolean[][] vis = new boolean[n][m];
	for(int i = 0;i<n;i++){
		for(int j = 0;j<m;j++){
			if(!vis[i][j] && grid[i][j]=='1'){
				ans++;
				dfs(grid,vis,n,m,i,j);
			}
		}
	}
	return ans;
}

public void dfs(char[][] grid, boolean[][] vis, int n, int m,int i, int j){
	// 注意返回的条件
	if(i<0||j<0||i>=n||j>=m){
		return;
	}
	if(grid[i][j]!='1') return;
	if(vis[i][j]) return;
	vis[i][j] = true;
	for(int[] dir:dirs){
		dfs(grid,vis,n,m,i+dir[0],j+dir[1]);
	}
}
```

思路2：也可以用并查集，每个组长代表着一个连通分量
相比于普通的一维并查集，主要是多了将二维坐标转成一维的操作

```java
class UnionFind {
	int count;
	int[] parent;
	int[] rank;

	public UnionFind(char[][] grid) {
		count = 0;
		int m = grid.length;
		int n = grid[0].length;
		parent = new int[m * n];
		rank = new int[m * n];
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				if (grid[i][j] == '1') {
					// i*n+j来转换坐标
					parent[i * n + j] = i * n + j;
					count++;
				}
				rank[i * n + j] = 0;
			}
		}
	}

	public int find(int i) {
		if (parent[i] != i)
			parent[i] = find(parent[i]);
		return parent[i];
	}

	public void union(int x, int y) {
		int rootx = find(x);
		int rooty = find(y);
		if (rootx != rooty) {
			if (rank[rootx] > rank[rooty]) {
				parent[rooty] = rootx;
			} else if (rank[rootx] < rank[rooty]) {
				parent[rootx] = rooty;
			} else {
				parent[rooty] = rootx;
				rank[rootx] += 1;
			}
			count--;
		}
	}

	public int getCount() {
		return count;
	}
}

public int numIslands(char[][] grid) {
	int[][] dirs = { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } };
	if (grid == null || grid.length == 0) {
		return 0;
	}

	int nr = grid.length;
	int nc = grid[0].length;
	int num_islands = 0;
	UnionFind uf = new UnionFind(grid);
	for (int r = 0; r < nr; r++) {
		for (int c = 0; c < nc; c++) {
			if (grid[r][c] == '1') {
				grid[r][c] = '0';
				for (int[] dir : dirs) {
					int x = r + dir[0];
					int y = c + dir[1];
					if (x >= 0 && y >= 0 && x < nr && y < nc && grid[x][y] == '1') {
						uf.union(r * nc + c, x * nc + y);
					}
				}
			}
		}
	}
	return uf.getCount();
}
```