#回溯
给一个边长n的正方形棋盘，放置n个棋子，一行、一列或一个斜线只能有一个棋子，输出所有可以放置的情况

可以理解为，结果棋盘中每一行、每一列、每斜线肯定会有一个棋子

思路：每一行只可能有一个棋子，所以用一维数组存储棋盘。可以用回溯来处理棋盘数组，如果能放皇后，就搜索这个地方放的情况，之后恢复成这个地方没放皇后。通过三个集合来存放这列和两条斜线的皇后情况，用特殊的计算公式让同一斜线的皇后的计算结果一致。

快速记忆：
1. 创建结果数组，棋盘数组，列标记，两条斜线的标记
2. 传入这些，和所在行，棋盘边长给回溯
3. 如果遍历完每一行，就把棋盘数组转换成对应格式给结果数组
4. 遍历这一行的每一列。如果不能放棋子就跳过，能放就先放后深搜下一行，深搜完后回溯到放之前的状态

```java
public List<List<String>> solveNQueens(int n) {
	List<List<String>> ans = new ArrayList<>();
	int[] queens = new int[n];
	Set<Integer> columns = new HashSet<>();
	Set<Integer> diagols1 = new HashSet<>();
	Set<Integer> diagols2 = new HashSet<>();
	backtrack(0,ans, n, queens, columns,diagols1, diagols2);
	return ans;
}

public void backtrack(int row, List<List<String>> ans, int n, int[] queens, Set<Integer> columns, Set<Integer> diagols1, Set<Integer> diagols2){
	if(row == n){
		List<String> output = generateBoard(queens, n);
		ans.add(output);
		return;
	}
	for(int col = 0;col<n;col++){
		if(columns.contains(col) || diagols1.contains(row-col) || diagols2.contains(row+col)){
			continue;
		}
		queens[row] = col;
		columns.add(col);
		diagols1.add(row-col);
		diagols2.add(row+col);
		backtrack(row+1,ans, n, queens, columns,diagols1, diagols2);
		columns.remove(col);
		diagols1.remove(row-col);
		diagols2.remove(row+col);
	}
}

public List<String> generateBoard(int[] queens, int n){
	List<String> output = new ArrayList<>();
	for(int i = 0;i<n;i++){
		char[] ch = new char[n];
		Arrays.fill(ch, '.');
		ch[queens[i]] = 'Q';
		output.add(new String(ch));
	}
	return output;
}
```