可以发现实际上就是把每条线的方向反转

思路1：一个节点指向一旦变化就不能通过next到达下一节点，所以要保存到下一节点的指针，同时要让该节点指向上一节点，也要保存到上一节点的指针。维护当前节点指针，下一节点指针，上一节点指针

快速记忆1：
- 初始化上一节点指针为空
- 遍历这个链表
- 每次遍历暂存下一节点指针，让当前节点指向上一节点
- 然后上一节点指针指向当前节点，当前节点移动到下一节点指针
- 最后当前节点为空，当前节点的上一节点为答案，返回

```java
public ListNode reverseList(ListNode head) {
	ListNode pre = null;
	while(head!=null){
		ListNode next = head.next;
		head.next = pre;
		pre = head;
		head = next;
	}
	return pre;
}
```

思路2：用递归的方式做，可以发现每个节点被下一节点的结果的尾节点的next连接

快速记忆2：
- 如果当前节点的链表无节点或只有一个节点，直接返回当前节点
- 翻转下一节点的结果，并获取翻转结果的头结点
- 通过下一节点指针获取翻转结果的尾节点，并把next指向当前节点
- 返回这次翻转结果的头结点

```java
public ListNode reverseList(ListNode head) {
	if(head==null || head.next==null) return head;
	ListNode res = reverseList(head.next);
	head.next.next = head;
	head.next = null;
	return res;
}
```