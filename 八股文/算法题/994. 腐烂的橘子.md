每个烂橘子每天都会影响相邻的新鲜橘子腐烂
全腐烂的那一天是什么时候

思路：采用广度优先遍历，记录新鲜橘子个数

```java
public int orangesRotting(int[][] grid) {
	int m = grid.length;
	int n = grid[0].length;
	Queue<Integer> q = new LinkedList<>();
	int cnt = 0, day = 0;
	for (int i = 0; i < m; i++) {
		for (int j = 0; j < n; j++) {
			if (grid[i][j] == 1) {
				cnt++;
			} else if (grid[i][j] == 2) {
				q.add(i * n + j);
			}
		}
	}
	int size = q.size();
	int[][] dirs = { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } };
	while (!q.isEmpty() && cnt > 0) {
		int count = 0;
		for (int i = 0; i < size; i++) {
			int num = q.poll();
			int row = num / n;
			int col = num % n;
			for (int[] dir : dirs) {
				int nrow = row + dir[0];
				int ncol = col + dir[1];
				if (nrow < 0 || ncol < 0 || nrow >= m || ncol >= n) {
					continue;
				}
				if (grid[nrow][ncol] == 1) {
					grid[nrow][ncol] = 2;
					cnt--;
					count++;
					q.add(nrow * n + ncol);
				}
			}
		}
		size = count;
		day++;
	}
	if(cnt!=0) return -1;
	return day;
}
```