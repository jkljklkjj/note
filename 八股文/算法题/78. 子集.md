#回溯 #位运算
给一个数组求所有子集

思路1：可以抽象成一个相同大小的boolean数组，这个数组的每个情况对应着一个子集。用数字来表示这个数组，每次自增就能对应新的情况

快速记忆1：
1. 初始化二进制有相同位数的数字作为boolean数组
2. 遍历这个数字的每一位，检查是否为1，为1则添加对应位置的数字
3. 将这次的添加结果添加进结果数组

```java
public List<List<Integer>> subsets(int[] nums) {
	List<List<Integer>> res = new ArrayList<>();
	int n = nums.length;
	// 每一位对应着boolean数组的一位
	int total = 1 << n;
	
	for (int i = 0; i < total; i++) {
		List<Integer> subset = new ArrayList<>();
		
		for (int j = 0; j < n; j++) {
			// 检查boolean数组第j位是否为1
			if ((i & (1 << j)) != 0) {
				subset.add(nums[j]);
			}
		}
		res.add(subset);
	}
	
	return res;
}
```

思路2：可以用回溯来模拟上面的解法。每个位置分别将自己取和不取的情况传入下一层递归

```java
public List<List<Integer>> subsets(int[] nums) {
	List<Integer> t = new ArrayList<>();
	List<List<Integer>> ans = new ArrayList<>();
	dfs(0,nums,t,ans);
	return ans;
}

public void dfs(int cur, int[] nums, List<Integer> t, List<List<Integer>> ans){
	if(cur == nums.length){
		ans.add(new ArrayList<Integer>(t));
		return;
	}
	t.add(nums[cur]);
	dfs(cur+1,nums,t,ans);
	t.removeLast();
	dfs(cur+1,nums,t,ans);
}
```