#链表
每组内部是翻转链表，外部就把尾部链接原上组尾部，头部链接原下组头部

思路：维护四个指针，当前组的头结点，上一组的尾节点，当前组的尾节点，下一组的头结点
先通过当前组的头尾节点翻转链表，返回新的头尾节点，然后通过上一组尾节点和下一组头结点完美翻转这个组的链表。最后让这四个指针到达新位置

快速记忆：
1. 设置虚拟头结点
2. 新建上一组尾节点为虚拟头结点
3. 当当前组头结点不为空的时候
4. 新建当前组尾节点为上一组尾节点，走k次成为对应节点，如果这一组数量小于k则返回
5. 新建下一组头结点
6. 通过当前组的头尾节点翻转组内链表，并获取新的头尾节点
7. 上一组尾节点和下一组头结点链接翻转后的链表
8. 更新上一组尾节点为当前组尾节点，头结点为下一组的头结点

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
	    // 虚拟头结点
        ListNode dummyHead = new ListNode(0,head);
        // 当前组的头结点的上一个节点
        ListNode pre = dummyHead;
        while(head!=null){
	        // 当前组的尾节点
            ListNode tail = pre;
            for(int i = 0;i<k;i++){
                tail = tail.next;
                if(tail==null){
                    return dummyHead.next;
                }
            }
            // 下一组的头结点
            ListNode next = tail.next;
            // 获取翻转链表后的头结点和尾节点
            ListNode[] reverse = reverse(head, tail);
            head = reverse[0];
            tail = reverse[1];
            // 更新所有指针到新一组
            pre.next = head;
            tail.next = next;
            pre = tail;
            head = tail.next;
        }
        return dummyHead.next;
    }

    public ListNode[] reverse(ListNode head, ListNode tail){
	    // 也可以初始化为null，这里是为了逻辑清晰
        ListNode pre = tail.next;
        ListNode p = head;
        while(pre!=tail){
            ListNode next = p.next;
            p.next = pre;
            pre = p;
            p = next;
        }
        return new ListNode[]{tail, head};
    }
}
```

```java
import java.util.*;  
  
public class Main {  
	static class ListNode{  
	    int val;  
	    ListNode next;  
	    public ListNode(int val){  
	        this.val = val;  
	    }  
	}  
  
    public static void main(String[] args) {  
        Scanner sc = new Scanner(System.in);  
        String t = sc.nextLine();  
        String[] ts = t.split(" ");  
        ListNode dummyHead = new ListNode(0);  
        ListNode cur = dummyHead;  
        for(String s:ts){  
            int val = Integer.valueOf(s);  
            ListNode node = new ListNode(val);  
            cur.next = node;  
            cur = cur.next;  
        }  
        int k = sc.nextInt();  
        ListNode solve = solve(dummyHead.next, k);  
        while(solve!=null){  
            System.out.print(solve.val+" ");  
            solve = solve.next;  
        }  
    }  
  
    public static ListNode solve(ListNode head, int k){  
        ListNode hair = new ListNode(0);  
        hair.next = head;  
        ListNode cur = hair;  
        ListNode pre = hair;  
        while(head!=null){  
            ListNode tail = pre;  
            for(int i = 0;i<k;i++){  
                tail = tail.next;  
                if(tail == null){  
                    return hair.next;  
                }  
            }  
            ListNode next = tail.next;  
            ListNode[] nodes = myReverse(head, tail);  
            head = nodes[0];  
            tail = nodes[1];  
            pre.next = head;  
            tail.next = next;  
            pre = tail;  
            head = tail.next;  
        }  
        return hair.next;  
    }  
  
    public static ListNode[] myReverse(ListNode head, ListNode tail){  
        ListNode pre = tail.next;  
        ListNode p = head;  
        while(pre!=tail){  
            ListNode next = p.next;  
            p.next = pre;  
            pre = p;  
            p = next;  
        }  
        return new ListNode[]{tail, head};  
    }  
}
```