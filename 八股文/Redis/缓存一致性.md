缓存是独立于数据库的高速、量小的另一类数据库

因为缓存和数据库始终是独立的，不会相互影响，所以可能会导致不一致的问题
也就是说，缓存做到了**性能的提高，却也牺牲了一致性**

在数据库的数据发生改变时，我们必须通过一些方法来尽量保证缓存和数据库在任何时间保存的数据都是一致的

因为更新缓存的操作十分困难和少见，我们不讨论这种情况

#### 先删缓存后更新数据库
假设线程 A 删除缓存值后，还没有来得及更新数据库（比如说有网络延迟），线程 B 就开始读取数据了，那么这个时候，线程 B 会发现缓存缺失，就只能去数据库读取。这会带来两个问题：

1. 线程 B 读取到了旧值；
2. 线程 B 是在缓存缺失的情况下读取的数据库，所以，它还会把旧值写入缓存，这可能会导致其他线程从缓存中读到旧值。
![](https://i-blog.csdnimg.cn/blog_migrate/c3089effad4fbe88bb23956e33ccf04f.png)

#### 延迟双删
在上面的基础上，**在线程 A 更新完数据库值以后，我们可以让它先 sleep 一小段时间，再进行一次缓存删除操作。**

- 之所以要加上 sleep 的这段时间，就是为了让线程 B 能够先从数据库读取数据，再把缺失的数据写入缓存，然后，线程 A 再进行删除。所以，线程 A sleep 的时间，就需要大于线程 B 读取数据再写入缓存的时间。这个时间怎么确定呢？建议你在业务程序运行的时候，统计下线程读数据和写缓存的操作时间，以此为基础来进行估算。
- 这样一来，其它线程读取数据时，会发现缓存缺失，所以会从数据库中读取最新值。因为这个方案会在第一次删除缓存值后，延迟一段时间再次进行删除，所以我们也把它叫做“延迟双删”

#### 先更新数据库再删除缓存

- 如果线程 A 删除了数据库中的值，但还没来得及删除缓存值，线程 B 就开始读取数据了，那么此时，线程 B 查询缓存时，发现缓存命中，就会直接从缓存中读取旧值。
- 不过，在这种情况下，如果其他线程并发读缓存的请求不多，那么，就不会有很多请求读取到旧值。而且，线程 A 一般也会很快删除缓存值，这样一来，其他线程再次读取时，·就会发生缓存缺失，进而从数据库中读取最新值。所以，这种情况对业务的影响较小。
![](https://i-blog.csdnimg.cn/blog_migrate/4c34e3002264b423d6251c3a6ec3a115.png)
#### 订阅Binlog并异步更新缓存

通过阿里云提供的Canal可以监听数据库的Binlog，如果发生变化，则会把删除缓存的请求发送到消息队列，最终消费者删除对应的缓存